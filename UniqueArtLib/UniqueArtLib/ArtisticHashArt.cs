// ArtisticHashArt.cs
using System;
using System.Text;
using System.Security.Cryptography;

namespace UniqueArtLib
{
    // DLL độc lập: không I/O. Nhận input qua thuộc tính, trả output qua thuộc tính + return value.
    public class ArtisticHashArt
    {
        // Input properties (được set từ app gọi)
        public string InputText;
        public int GridSize;
        public bool Mirror;         // nếu true -> mirror trái-phải (kaleidoscope)
        public string Author;       // dấu ấn cá nhân, default = Environment.UserName

        // Outputs (được đọc bởi app gọi)
        public string OutputArt;    // art đã tạo (multi-line)
        public string Metadata;     // digest / time / author tóm tắt

        // Constructor với giá trị mặc định
        public ArtisticHashArt()
        {
            InputText = "";
            GridSize = 9;
            Mirror = true;
            Author = Environment.UserName; // dấu ấn cá nhân mặc định
            OutputArt = "";
            Metadata = "";
        }

        // Hàm chính: tạo art, trả về string và gán OutputArt
        public string GenerateArt()
        {
            if (GridSize < 3) GridSize = 3;
            if (GridSize % 2 == 0) GridSize++; // bắt buộc odd để mirror đối xứng đẹp

            // Tạo MD5 digest của input
            byte[] digest = ComputeMD5(InputText ?? "");

            // Lấy bit stream từ digest để fill grid
            int totalBits = digest.Length * 8;
            bool[,] grid = new bool[GridSize, GridSize];
            int halfColumns = Mirror ? (GridSize + 1) / 2 : GridSize;
            int bitIndex = 0;

            for (int r = 0; r < GridSize; r++)
            {
                for (int c = 0; c < halfColumns; c++)
                {
                    int b = GetBit(digest, bitIndex % totalBits);
                    grid[r, c] = (b == 1);
                    if (Mirror)
                    {
                        int mc = GridSize - 1 - c;
                        grid[r, mc] = grid[r, c];
                    }
                    bitIndex++;
                }
            }

            // Build ASCII art string
            StringBuilder sb = new StringBuilder();
            for (int r = 0; r < GridSize; r++)
            {
                for (int c = 0; c < GridSize; c++)
                {
                    sb.Append(grid[r, c] ? "#" : " ");
                    sb.Append(" "); // space between cells for readability
                }
                sb.AppendLine();
            }

            string hex = ToHex(digest);
            string time = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");

            // personal signature + metadata (dấu ấn cá nhân)
            sb.AppendLine();
            sb.AppendLine("---");
            sb.AppendLine("Generated by: " + (Author ?? "Unknown"));
            sb.AppendLine("Input: " + (InputText ?? ""));
            sb.AppendLine("GridSize: " + GridSize + "  Mirror: " + Mirror);
            sb.AppendLine("Digest: " + hex);
            sb.AppendLine("Time: " + time);
            sb.AppendLine("---");

            OutputArt = sb.ToString();
            Metadata = "digest:" + hex + ";author:" + (Author ?? "") + ";time:" + time;
            return OutputArt;
        }

        private byte[] ComputeMD5(string s)
        {
            MD5 md5 = new MD5CryptoServiceProvider();
            byte[] data = Encoding.UTF8.GetBytes(s ?? "");
            return md5.ComputeHash(data);
        }

        private int GetBit(byte[] arr, int idx)
        {
            int byteIndex = idx / 8;
            int bitInByte = idx % 8;
            // lấy bit trọng số cao trước (big-endian trong byte)
            return (arr[byteIndex] >> (7 - bitInByte)) & 1;
        }

        private string ToHex(byte[] arr)
        {
            StringBuilder sb = new StringBuilder();
            for (int i = 0; i < arr.Length; i++) sb.Append(arr[i].ToString("x2"));
            return sb.ToString();
        }
    }
}
